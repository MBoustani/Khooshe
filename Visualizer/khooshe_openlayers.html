<html>
<head>
<title>Memex GeoParser</title>

<link rel="stylesheet" href="static/css/bootstrap.css" rel="stylesheet" />

<script src="static/js/jquery-1.11.1.min.js"></script>
<script src="static/js/bootstrap.min.js"></script>
<script src="static/js/ol.js"></script>
<script src="static/js/jquery.csv.js"></script>

</head>
<body>
  <div id='map'></div>

  <script type="text/javascript">
			var layer = new ol.layer.Tile(
					{
						source : new ol.source.XYZ(
								{
									url : 'http://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
									attributions : [ new ol.Attribution(
											{
												html : [ '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, &copy; <a href="http://cartodb.com/attributions">CartoDB</a>' ]
											}) ]
								})
					});

			var view = new ol.View({
				center : ol.proj.transform([ -98.5, 39.76 ], 'EPSG:4326', 'EPSG:3857'),
				zoom : 2
			});

			map = new ol.Map({
				layers : [ layer ],
				target : 'map',
				view : view
			});

			//ALL Above will be part of app code

			//Below will go in khooshe-ol.js
			var _dict = {}
			var _map = {}
			var _default_layer_name = 'test'
			var _base_dir = "static/tiles/"

			/**
			 * This variable holds Khooshe layer for all available instance.   
			 **/
			var _layerKhooshe = {}
			var khooshe = function(map) {
				_map = map
			}
			//todo define init and move all methonds under khooshe
			var _deleteLayers = function(dataPoints) {
				if (!dataPoints || !dataPoints.length || dataPoints.length == 0) {
					return;
				}

				for ( var i in dataPoints) {
					map.removeLayer(dataPoints[i]);
				}
			}
			var _getCurrentExtent = function(){
				var currentExtent = map.getView().calculateExtent(map.getSize());
				currentExtent = ol.proj.transformExtent(currentExtent, 'EPSG:3857', 'EPSG:4326');
				return currentExtent
			}
			//Checks if zoom level is changed and logs number of features visible while zoom
			map.on('moveend', function() {
				if (!_layerKhooshe['test']) {
					return
				}
				var visible_layers = {}
				var min_layer = 999999
				//current extent in lat and long format
				var currentExtent = _getCurrentExtent()

				//use dictionary to get available extents
				for ( var i in _dict) {
					extent = _dict[i].extent.split(',')
					extent = extent.map(function(item) {
						return parseFloat(item);
					})
					if (ol.extent.containsExtent(currentExtent, extent)) {
						//update min layer if possible
						if (_dict[i].folder < min_layer) {
							min_layer = _dict[i].folder
						}
						//append in visible layer array
						if (!visible_layers[_dict[i].folder]) {
							visible_layers[_dict[i].folder] = []
						}
						visible_layers[_dict[i].folder].push(_dict[i].file)
					}
				}
				console.log(currentExtent)
				console.log(visible_layers)
				//remove existing layers
				if (visible_layers[min_layer] && visible_layers[min_layer].length != 0) {
					_deleteLayers(_layerKhooshe['test'])
					_layerKhooshe['test']=[]
				}
				//display new layer
				for ( var i in visible_layers[min_layer]) {
					_drawKhoosheLayer(min_layer, visible_layers[min_layer][i])
				}

			});

			/**
			 * Adjust size array within limits of min and max size
			 **/
			var _adjust = function(dataPoints) {
				//console.log(dataPoints.map(function(point){return point.label;}) )
				//define max and min bubble size
				var minSize = 4
				var maxSize = 50
				var maxMinDelta = maxSize - minSize
				//get maximum sized point
				maxIpSize = Math.max.apply(Math, dataPoints.map(function(point) {
					return point.label;
				}))
				//adjust data points wrt max maxIpSize.
				if (maxIpSize > maxSize) {
					for ( var i in dataPoints) {
						dataPoints[i].label = minSize + (maxMinDelta * (dataPoints[i].label / maxIpSize))
					}
				}
				//console.log(dataPoints.map(function(point){return point.label;}) )
				return dataPoints
			}

			var _drawPoints = function(dataPoints, layer) {
				if (!layer) {
					layer = _default_layer_name
				}
				if (!dataPoints.length || dataPoints.length == 0) {
					return;
				}

				var icon_feature = [];
				dataPoints = _adjust(dataPoints)
				for ( var i in dataPoints) {
					var point = dataPoints[i];
					var iconFeature = new ol.Feature({
						geometry : new ol.geom.Point([ parseFloat(point.longitude), parseFloat(point.latitude) ]).transform(
								'EPSG:4326', 'EPSG:3857'),
						name : i
					});
					var ccl = new ol.style.Circle({
						radius : point.label,
						fill : new ol.style.Fill({
							color : 'red'
						}),
						stroke : new ol.style.Stroke({
							color : 'silver',
							width : 1
						})
					})
					ccl.setOpacity(0.5)
					var iconStyle = new ol.style.Style({
						image : ccl

					});

					iconFeature.setStyle(iconStyle);
					icon_feature.push(iconFeature);
				}

				var vectorSource = new ol.source.Vector({
					features : icon_feature
				});

				var vectorLayer = new ol.layer.Vector({
					source : vectorSource
				});

				map.addLayer(vectorLayer);

				if (!_layerKhooshe[layer]) {
					_layerKhooshe[layer] = [];
				}
				_layerKhooshe[layer].push(vectorLayer)
			}

			_drawKhoosheLayer = function(folder, file) {
				$.ajax({
					type : "GET",
					url : _base_dir + folder + "/" + file + ".csv",
					dataType : "text",
					success : function(data) {
						_drawPoints($.csv.toObjects(data));
					}
				});
			}
			_drawKhoosheLayer(0, 0)
			$.ajax({
				type : "GET",
				url : _base_dir + "dict.csv",
				dataType : "text",
				success : function(data) {
					_dict = $.csv.toObjects(data)
				}
			});
		</script>
</body>
</html>
